<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS数据可视化技术选型之Canvas与SVG]]></title>
    <url>%2F2019%2F03%2F27%2Fcanvas-svg%2F</url>
    <content type="text"><![CDATA[Canvas 是HTML5新增的标签元素，它就像一个画布，JS通过操作HTML5提供的绘图 API在Canvas标签上绘制图形，与SVG相反，Canvas绘制的是位图，也叫标量图、点阵图。 SVG全称Scalable Vector Graphics，可缩放矢量图，单看这名字就知道是用来绘制矢量图的。W3C上是这样描述的：SVG是一种基于XML语法的图像格式，通过XML文档描述绘图。什么意思？通俗点讲就是SVG是通过标签元素DOM来绘制图形。相比Canvas，SVG是位老前辈了，2003年这位前辈就已经是W3C 标准，但是由于它长相复杂而且有点不求上进，十几年来发展非常缓慢。 在HTML5还没有发布的年代，浏览器的内置功能在可视化方面可做的事情非常有限，不得不借助Flash。HTML5新增了Canvas标签、改进SVG特性并支持内联SVG，促使web前端数据可视化后来居上，成为数据可视化领域的网红利器。当前主流的JavaScript数据可视化库，比如D3、Echarts、HighCharts、AntV等均是基于Canvas或者SVG的绘图技术，而且D3、Echarts、AntV已经同时支持Canvas和SVG渲染。Canvas与SVG虽说都是浏览器内置的2D图形绘制技术，在HTML5中感觉很相似，但是两者有着本质的不同，并且各有优缺点。WebGL是Canvas的3D绘图标准，能实现3D数据可视化，这里不详细说，说到Canvas通常指它的2D绘图功能。 举个例子，用Canvas和SVG分别绘制一个同样的散点图。使用Canvas绘制散点图HTML代码12&lt;canvas data-zr-dom-id="zr_0" width="1600" height="1200" style="position: absolute; left: 0px; top: 0px; width: 800px; height: 600px; user-select: none; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); padding: 0px; margin: 0px; border-width: 0px;"&gt;&lt;/canvas&gt;​使用SVG绘制散点图HTML代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;svg width="1600" height="1200" preserveAspectRatio="xMidYMid meet" viewBox="0 0 998 577"&gt; &lt;g class="main" transform="translate(499,288.5) scale(1)"&gt; &lt;g class="base" transform="translate(-1.9987640206820743,0.6762029975734265) scale(0.9917167307382942)"&gt; &lt;g class="axis" fill="none" font-size="10" font-family="sans-serif" text-anchor="middle" transform="translate(0,-24.041666666666686)"&gt; &lt;path class="domain" stroke="currentColor" d="M-373.75,4V0.5H374.75V4"&gt;&lt;/path&gt; &lt;g class="tick" opacity="1" transform="translate(-373.75,0)"&gt; &lt;line stroke="currentColor" y2="4"&gt;&lt;/line&gt;&lt;text fill="currentColor" y="7" dy="0.71em"&gt;0&lt;/text&gt; &lt;/g&gt; &lt;!--..... --&gt; &lt;!-- 此处省略10行g标签 --&gt; &lt;/g&gt; &lt;g class="axis" fill="none" font-size="10" font-family="sans-serif" text-anchor="end" transform="translate(-213.59320669671604,0)"&gt; &lt;path class="domain" stroke="currentColor" d="M-4,-215.875H0.5V216.875H-4"&gt;&lt;/path&gt; &lt;g class="tick" opacity="1" transform="translate(0,-215.875)"&gt; &lt;line stroke="currentColor" x2="-4"&gt;&lt;/line&gt;&lt;text fill="currentColor" x="-7" dy="0.32em"&gt;6&lt;/text&gt; &lt;/g&gt; &lt;!--..... --&gt; &lt;!-- 此处省略10行g标签 --&gt; &lt;/g&gt; &lt;g class="rect"&gt; &lt;rect width="748.5" height="432.75" transform="translate(-374.25,-216.375)"&gt;&lt;/rect&gt; &lt;/g&gt; &lt;g class="texts"&gt;&lt;text transform="translate(0,231.375)" style="text-anchor: middle;"&gt;学科产出专利数量（件）&lt;/text&gt;&lt;/g&gt; &lt;g class="texts"&gt;&lt;text transform="translate(-389.25,0) rotate(-90)" style="text-anchor: middle;"&gt;被引频次增长率（%）&lt;/text&gt;&lt;/g&gt; &lt;/g&gt; &lt;g class="points"&gt; &lt;circle r="5" transform="translate(-103.09112994504476,-28.888525606953024)" style="fill: rgb(24, 144, 255);"&gt;&lt;/circle&gt; &lt;circle r="5" transform="translate(-286.31606424452,-23.166320070593084)" style="fill: rgb(47, 194, 91);"&gt; &lt;/circle&gt; &lt;circle r="5" transform="translate(-362.4739065011714,-34.13388068194967)" style="fill: rgb(47, 194, 91);"&gt; &lt;/circle&gt; &lt;!--..... --&gt; &lt;!-- 此处省略19行circle标签 --&gt; &lt;/g&gt; &lt;/g&gt;&lt;/svg&gt; 比较两种渲染代码，显而易见 canvas体型小，无论什么样的可视化图表，在页面上一个canvas标签元素就够了；svg相对体型巨大，一个简单的可视化图表就需要数十个标签。这样的结构差异造成了canvas和svg的四点区别： ① 事件监听 canvas的事件触发是粗粒度的，仅支持在canvas元素级别；svg图形中的每一个DOM都可以绑定事件。因此，要实现图表交互，canvas必须通过鼠标坐标进行手动编程设置，svg在相应的DOM上监听事件即可。 ② 图形保存 canvas上绘制的图形是一个位图，能够以.png或者jpg格式保存成图像；svg本身就是一个图像格式，把svg标签内容保存成.svg格式文件就是一个图像文件了（注意svg标签里需要声明命名空间）。 ③ 动画制作 canvas中的图形绘制完成就得不到浏览器的继续关注了，如果要让图形运动就需要擦除图形然后重新绘制，利用人眼睛的视觉误差来形成动画；svg图形创建后，其内部图形元素（DOM）是真实存在的，支持可访问性，可以通过改变图形元素的属性来形成动画。 ④ 渲染性能 canvas是对单个标签的渲染，svg是对多标签的渲染；因此，canvas适用于小面积大数据量（10k以上）的应用场景，而svg更适用于大面积小数据量的应用场景。 因此，实时大规模数据可视化优先使用Canvas；高保真度的复杂静态图形可视化，如建筑图、工程图、大规模地图（百度地图、谷歌地图等）等优先使用SVG；普通交互式图表和图形可视化方面，SVG与Canvas都能胜任，此时需要结合其他客观因素（如平台：移动端 or PC端、学习成本等）进行技术选型。 大概就这么多了~~~]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node+echarts实现服务器端渲染可视化图表]]></title>
    <url>%2F2019%2F03%2F25%2Fnode-echarts%2F</url>
    <content type="text"><![CDATA[近几年，随着大数据的兴起、浏览器性能的提升以及web前端技术的快速迭代，基于js的web前端数据可视化技术（D3、echarts 、highcharts、AntV等）成为了数据可视化领域的”当红炸子鸡”。数据可视化产品通常是To B的产品，这些js库最常使用的场景就是在客户浏览器端渲染展示可视化图表。但是如果要一次性创建上百张信息图表，在浏览器端渲染生成显然不科学，这就需要在服务器端使用后端语言(java、python等）预先渲染成图片。Node.js的出现将js的触角伸向了服务器端，这里探讨一下如何使用Node实现服务器端渲染可视化图表。 Node实现服务器端渲染可视化图表主要有两种方案: 第一种方案：使用流行的headless环境，也就是所谓的无头浏览器，包括puppeteer、headless chrome、PhantomJS等。通过node操作无头浏览器渲染可视化图表，并调用浏览器截图API把渲染的结果截图保存下来。 第二种方案：使用Node调用canvas模块直接在后端渲染可视化图表并保存。 废话不多说，直接撸代码。 ————————–分割线————————– 第一种方案headless环境选择Puppeteer，js可视化库选择echarts。Puppeteer是谷歌官方出品的一个通过DevTools协议控制headless Chrome的Node库，感兴趣可以去其官网详细了解一下。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//导入两个模块Puppeteer和pathconst puppeteer = require('puppeteer');//npm install安装一下const path = require('path');//Node内置模块//定义渲染可视化图表并截图函数const render = async(subject,arrData)=&gt;&#123; // 启动浏览器 const browser = await puppeteer.launch(&#123;args: ['--no-sandbox'],timeout:0&#125;); //创建空白页面 const page = await browser.newPage(); //定义网页模板 let htmlTemplate = `&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="canvas" style="width:1400px;height:800px"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;` //设置网页源码 await page.setContent(htmlTemplate); // 传递数据到evaluate函数中，挂载到window对象的全局属性中 await page.evaluate((arrData)=&gt;&#123; window.chart = &#123;arrData:arrData&#125; &#125;,arrData); //在网页中导入echarts库 await page.addScriptTag(&#123; path: path.resolve(__dirname, '../public/js/echarts.min.js') &#125;); //在网页中导入可视化图表渲染代码 await page.addScriptTag(&#123; content:` (function (window) &#123; var option = &#123; //echarts配置项 //..... &#125;; var myChart = window.echarts.init(document.getElementById('canvas')); myChart.setOption(option); &#125;)(this);` &#125;); //对渲染后的图表截图 let canvas = await page.$('#canvas'); await canvas.screenshot(&#123; type: 'jpeg',//默认png quality:100, path:path.resolve(__dirname, '../public/images/'+subject+".jpg") &#125;); // 关闭网页 await page.close(); // 关闭浏览器 await browser.close();&#125; 第二种方案使用Node的canvas模块，js可视化库选择echarts 12345678910111213141516171819const canvas = require("canvas");//npm install canvasconst echarts = require("echarts");//npm install echartsconst fs = require('fs');//node内置模块,直接引入//创建一个canvas实例let ctx = canvas.createCanvas(800,600)//将canvas实例设置为echarts容器echarts.setCanvasCreator(()=&gt;ctx)//使用canvas实例为容器创建echarts实例let chart = echarts.init(ctx)//echarts配置项let option = &#123; //....&#125; //设置图标实例配置项chart.setOption(option);//保存图片const imgPath = __dirname + '/bubble.png'fs.writeFileSync(imgPath, chart.getDom().toBuffer()); 相比第一种方案，第二方案更加快捷、高效，推荐使用第二方案。如果不想写这么多代码，有一个node-echarts的模块可以拿过来直接用。 最后，来看下渲染结果（以散点图为例）。perfect &amp; 无懈可击！]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器返回的状态码]]></title>
    <url>%2F2018%2F07%2F24%2Fhttp-code%2F</url>
    <content type="text"><![CDATA[关于状态码用户从客户端向服务器发送请求后，服务器接收请求后会向用户返回状态码，用于告诉用户服务器响应的状态。通过状态码可以知道当前请求服务器是否响应成功，如果没有成功是出了什么问题。状态码由三位数字组成，第一位数字表示响应类别，分别以1-5数字打头。 1XX 信息性状态码（Information） 服务器正在处理请求 2XX 成功状态码 （Success） 请求已经正常处理完毕 3XX 重定向状态码 (Redirection) 需要进行额外操作来完成请求 4XX 客户端错误状态码 (Client Error) 客户端原因导致服务器无法处理请求 5XX 服务器错误状态码 (Server Error) 服务器原因导致处理请求出错 根据后两位数字的不同，在5类的基础上进行细分。RFC2616（用来指定HTTP协议标准的文档）标准定义的HTTP状态码有四十多种，但是常见且具有代表性的共有14种，其中2XX（成功）3个，3XX（重定向）5个,4XX(客户端错误)4个，5XX(服务器错误)2个。 2XX成功 200 OK. 表示请求被服务器正常处理。 204 No Content. 表示请求已经被成功处理，但是没有内容返回。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。这种情况浏览器页面不会更新。 206 Partial Content.表示服务器已经完成了部分GET请求（客户端进行了范围请求）。 3XX重定向 301 Moved Permanently.永久重定向，表示请求的资源已经永久的搬到了其他位置，即资源已经被分配了新的URI，新的URI应该提示在响应报文的Location首部字段，只要不是HEAD请求，响应实体应该包含新URI的超链接和简短的说明。 302 Found.临时重定向，表示请求的资源临时搬到了其他位置。请求的资源暂时被配到到了新的URI。 303 See Other. 表示请求资源存在另一个URI，应使用GET定向获取请求资源。 304 Not Modified. 表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。虽然304被划分在3XX，但和重定向一毛钱关系都没有 307 Temporary Redirect.临时重定向,与302含义相同，区别是307会遵照标准，不会从POST变为GET。 4XX客户端错误 400 Bad Request. 表示请求报文存在语法错误或参数错误，服务器不理解。 401 Unauthorized. 表示发送的请求需要HTTP认证信息或者认证失败。 403 Forbidden. 表示对请求资源的访问被服务器拒绝了。 404 Not Found.表示服务器找不到你请求的资源。也有可能服务器就是不想给你然后骗你找不到。 5XX服务器错误 500 Internal Server Error. 表示服务器执行请求的时候出错了,可能是Web应用有bug或临时故障,更有可能是服务器源代码有bug… 503 Service Unavailable.表示服务器超负载或正停机维护，无法处理请求。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP状态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解BFC]]></title>
    <url>%2F2018%2F02%2F13%2FBFC%2F</url>
    <content type="text"><![CDATA[什么是BFC？BFC，全称Block Formatting Context,翻译成中文“块级格式化上下文”。BFC=block-level box（块级元素） + Formatting Context（普通流，从上到下依次显示）。BFC是一块独立的渲染区域，这块区域对外具有隔离特性，其子元素不会对外部其他元素产出影响。通俗讲，BFC就是一个CSS属性，元素具有该属性后不能被开发者显式修改，且拥有这个属性的元素会表现一些特性。 BFC触发条件（5个） 根元素，即HTML元素 float属性值不是none position属性值不是static或者positive overflow属性值不是visible display属性值是inline-block,table-cell,table-caption BFC特性（6个） BFC内部块元素垂直方向一个接一个地放置。 BFC内部块元素垂直方向距离由margin决定，同一个BFC内部相邻的两个块元素的margin会重叠。 BFC区域不会float元素区域重叠 计算BFC高度时，浮动元素也参与计算 BFC子元素margin box左边与包含块border box的左边相接触（从左到右的格式化，反之亦然）即使浮动元素也是如此。 BFC区域是一个隔离的独立容器，容器里的子元素不会影响外面的元素。 BFC作用 自适应两列或者多列布局 清除浮动 阻止两个相邻Box的margin重叠 阻止元素被浮动元素覆盖]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>BFC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js快速排序]]></title>
    <url>%2F2018%2F02%2F11%2Fjs-quickSort%2F</url>
    <content type="text"><![CDATA[快速排序的基本思想是:1．先从数列中取出一个数作为基准数。2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。3．再对左右区间重复第二步，直到各区间只有一个数 概括起来就是”挖坑填数，分二治之”。因为网上具体讲解快速排序的思路的博客很多，这里废话不多说，直接上代码。1234567891011121314151617181920212223242526272829function QuickSort(arr,low,high)&#123; var i = low;//数组第一个元素的索引 var j = high;//数组最后个元素的索引，arr.length-1 var x = arr[i]; if(i&gt;=j) return arr; //挖坑填数 while(i&lt;j)&#123; for(;j&gt;i;j--)&#123; if(arr[j]&lt;=x)&#123; arr[i]=arr[j]; i++; break; &#125; &#125; for(;j&gt;i;i++)&#123; if(arr[i]&gt;=x)&#123; arr[j]=arr[i]; j--; break; &#125; &#125; &#125; arr[i] = x; //分二置之 QuickSort(arr,low,i-1); QuickSort(arr,i+1,high); return arr;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csv文本格式数据导入MySQL的方法]]></title>
    <url>%2F2017%2F11%2F26%2Fcsv-into-mysql%2F</url>
    <content type="text"><![CDATA[LOAD DATA INFILE是从一个文本文件中以很高的速度读入一个数据表中的方法，具体语法：12345678910111213141516LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE &apos;file_name&apos; [REPLACE | IGNORE] INTO TABLE tbl_name [CHARACTER SET charset_name] [&#123;FIELDS | COLUMNS&#125; [TERMINATED BY &apos;string&apos;] [[OPTIONALLY] ENCLOSED BY &apos;char&apos;] [ESCAPED BY &apos;char&apos;] ] [LINES [STARTING BY &apos;string&apos;] [TERMINATED BY &apos;string&apos;] ] [IGNORE number &#123;LINES | ROWS&#125;] [(col_name_or_user_var,...)] [SET col_name = expr,...] LOW_PRIORITY 指定关键字LOW_PRIORITY,MySQL将会等到没有其他人读这个表的时候，才把插入数据.LOCAL 从本地客户端读取数据;如果没有指定LOCAL,文件必须位于服务器上.REPLACE和IGNORE关键词控制对现有的唯一键记录的重复的处理。如果你指定REPLACE，新行将代替有相同的唯一键值的现有行。如果你指定IGNORE，跳过有唯一键的现有行的重复行的输入。如果你不指定任何一个选项，当找到重复键时，出现一个错误，并且文本文件的余下部分被忽略.FIELDS 关键字指定了文件字段的分割格式，如果用到这个关键字，MySQL剖析器希望看到至少有下面的一个选项：TERMINATED BY分隔符：意思是以什么字符作为分隔符ENCLOSED BY字段括起字符ESCAPED BY转义字符TERMINATED BY描述字段的分隔符，默认情况下是tab字符（\t）ENCLOSED BY描述的是字段的括起字符。ESCAPED BY描述的转义字符。默认的是反斜杠（backslash：\）LINES 关键字指定了每条记录的分隔格式。STARTING BY 描述每条记录的开始字符TERMINATED BY 描述每条几轮的分隔符，默认是（\n）IGNORE number {LINES | ROWS} 指定忽略的行或者列 举个例子:1234LOAD DATA LOCAL INFILE &apos;/users/Shaun/desktop/yw2015.csv&apos; INTO TABLE yw2015j CHARACTER SET GBK FIELDS TERMINATED BY &apos;,&apos; ENCLOSED BY &apos;&quot;&apos; LINES TERMINATED BY &apos;\r\n&apos;;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除MySQL表格中的数据]]></title>
    <url>%2F2017%2F10%2F11%2Fmysql-delete-data%2F</url>
    <content type="text"><![CDATA[清除MySQL数据库中某个表格中所有数据内容，但保留数据表的基本结构，操作方法： 方法11DELETE FROM 表名; 不带WHERE参数的DELETE语句可以删除Mysql表中的所有内容。 方法21TRUNCATE TABLE 表名; 使用TRUNCATE TABLE可以清空mysql表中所有内容。 两种方法比较效率上TRUNCATE要比DELETE要快，但TRUNCATE删除后不记录mysql日志，不可以恢复数据。DELETE的效果相当于将mysql数据表中的所有记录一条一条删除到完。TRUNCATE相当于保留mysql表的结构，重新创建了这个表，所有的状态都相当于新表。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL导出数据字典]]></title>
    <url>%2F2017%2F09%2F01%2Fmysql-dictionary%2F</url>
    <content type="text"><![CDATA[MySQL数据库管理系统关于表格以及字段的信息分别存储在information_schema数据库的tables以及columns两个表中，使用这两个表关联查询可以生成对应表的数据字典. 举例：12345SELECT a.table_name,b.table_comment,a.column_name,a.column_type,a.column_commentFROM information_schema.columns a JOIN information_schema.tables b ON a.table_schema =b.table_schema AND a.table_name =b.table_nameWHERE a.table_name=&apos;jlist2016&apos; 然后导出查询结果为csv文件，再导进数据库即可。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据字典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计那些事]]></title>
    <url>%2F2017%2F07%2F29%2Fdatabase-design%2F</url>
    <content type="text"><![CDATA[什么是数据库设计？数据库设计就像建设大楼的过程，整体结构设计-图纸-施工。数据库设计就是根据业务系统的具体需要，结合需用的DBMS数据库管理系统，为这个业务构造出最优的数据存储模型，并建立好数据库中表的结构以及表与表之间的关联关系的过程。使之能有效的对应用系统中的数据进行存储，并可以高效的对已经存储的数据进行访问。 为什么要数据库设计？减少数据冗余，避免数据维护异常，节约存储空间，高效的访问。 数据库设计步骤数据库设计步骤：需求分析→逻辑设计→物理设计→维护优化 数据库需求分析数据是什么？数据有哪些属性？数据和属性各自的特点都有什么？需求分析了解的问题1.了解所要存储的数据2.数据的存储特点3.数据的生命周期时效性比较短的数据要定期清理或者归档。增长速度快、量大的非核心数据先定好数据库的归档和清理规则。要搞清楚的问题：1.实体与实体之间的关系 1对1 1对多 多对多2.实体所包含的属性3.哪些属性或属性的组合可以唯一标识一个实体实体与数据库中的表的关系：可能一个实体对应一个表，也可能多个实体对应一个表。 逻辑设计ER图工具对数据库进行逻辑建模需求转换为数据库的逻辑模型ER图对逻辑模型进行展示（与所选DBMS无关）。操作异常：插入异常，删除异常，更新异常插入异常：某实体随另一个实体的存在而存在，缺少某个实体时无法表示这个实体。更新异常：更改表锁定所对应的某个实体的单独属性时，需要多行更新。删除异常：删除表的某一行来反映实体实例失效时，导致另一个实体实例信息丢失。数据冗余：指相同的数据在多个地方存在，或者说表中的某个列可以由其它列计算得到。数据冗余容易造成数据表维护的困难。数据库设计范式：第一范式、第二范式、第三范式以及BC范式。第一范式:数据库表中的所有字段都是单一属性，单一属性数据类型是基本数据类型。即第一范式要求数据库中的表都是二维表第二范式:在第一范式基础上，非关键字段不能对候选关键字段部分函数依赖（组合关键字中的某一关键字决定非关键字），即所有单关键字段都符合第二范式。第三范式:在第二范式基础上定义的，非关键字段不能对任意候选关键字段有传递依赖。BC范式:复合关键字之间不能存在函数依赖关系。 物理设计考虑使用的数据库管理系统DBMS是什么？根据选择的DBMS特点把逻辑设计转化成物理设计。 选择合适的DBMS定义数据库、表及字段的命名规范所有对象命名应该遵循的原则：（1）可读性原则。使用大写和小写来格式化库对象名字。（2）表意性原则。对象的名字能够描述所标识的对象。（3）长名原则。尽可能少使用和不使用缩写。 根据选择的DBMS选择合适的字段类型字段类型选择原则：列的数据类型一方面影响数据存储的空间开销，另一方面也影响数据查询的性能。当一个列可以选择多种数据类型时，应该优先考虑数字类型，其次是日期或者二进制类型，最后是字符类型。对于相同级别的数据类型，应该优先选择占用空间小的数据类型。列类型 存储空间TINYINT 1字节SMALLINT 2字节MEDIUMINT 3字节INT 4字节BIGINT 8字节DATE 3字节DATETIME 8字节TIMESTAMP 4字节CHAR(M) M字节，1=&lt;M&lt;=255VARCHAR(M) L+1字节，L&lt;=M,1=&lt;M&lt;=255以上规则从两个角度考虑：（1）在对数据进行比较（查询条件、join、排序）时，同样的数据字符处理比数字处理要慢。（2）在数据库中，数据处理以页为单位，列长度越小，每页存储的数据越多，页数越少，有利于性能提升。Char 和Varchar如何选择：（1）如果列中存储的数据长度差不多一直，应该采用char，否则考虑varchar（2）如果列中最大数据长度小于50Byte，一般考虑char。如果该列很少用，基于节省空间和较少I/O考虑还是可以选用varchar的。（3）一般不宜定义大于50Byte的char类型。utf8每个字符占3个字节，15个字符以上用varchar。 反范式化设计数据表中增加冗余,达到效率的提升，以空间换时间。为了性能和读取效率的考虑，适当对第三范式的要求进行违反，允许存在少量的数据冗余。换句话说，反范式化就是用空间来换时间。好处是减少了表关联的数量，增加数据读取的效率，但反范式化一定要适度。 decimal和float如何选择：（1）decimal用于存储精确数据，float用于存储非精确数据。（2）由于float的存储空间开销小于decimal，故非精确数据有限选择float类型。 时间类型如何存储：如果很少被使用，使用INT类存储；否则经常查询使用的话，使用datetime类型来存储。 如何选择主键？区分也业务主键和数据库主键。业务主键用于标识业务数据，进行表与表之间的关联。数据库主键为了优化数据存储。一般情况下，业务主键与数据库主键相同，有时也不同。INNODB引擎的数据库要求每个表都有一个主键，按照主键的顺序进行逻辑存储，没有主键会自动生成6个字节的隐含主键，最好主键是顺序增长的。主键的字段类型所占的空间尽可能小，每页存储的主键越多，对性能越好。高并发的互联网网站避免使用外键，触发器以及预留字段。相关联的列上一定要建立索引。 维护优化根据新的需求进行建表，索引优化以及大表拆分。优化工作中继续按照上述三步进行优化设计、建表工作。（1）维护数据字典 加comment注释，然后命令导出数据字典.（2）维护索引。如何选择合适的列建立索引?出现在WHERE从句、GROUP BY、ORDER BY从句中的列。可选择性高的列放在索引前面。索引中不要包括太长的数据类型。MySQL支持前置性索引的，对Text类型数据的前16个字节索引。注意：索引不是越多越好，过多的索引不但降低写的效率而且会降低读的效率；要定期维护索引碎片；在SQL语句中不要使用强制索引关键字。（3）维护表结构。同时对数据字典进行维护并控制表的宽度的大小（数据表字段过大考虑垂直拆分）。数据库中适合批量操作，在数据库查询时少使用SELECT * 语句，控制用户使用自定义函数，不要使用数据库中的全文索引，最好使用搜索引擎工具来代替完成。（4）在适当时候对表进行水平拆分或者垂直拆分。经常一起查询的列放在一起，text、blob等大字段拆分出都附加表中。如果一张大表数据量达到上亿行，可能需要水平拆分（把一张表分成多份），通过主键Hash方式进行。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL存储过程]]></title>
    <url>%2F2017%2F07%2F19%2Fmysql-PROCEDURE%2F</url>
    <content type="text"><![CDATA[什么是存储过程？SQL命令-MySQL引擎分析语法是否正确-编译SQL命令-执行结果-返回客户端。如果省略语法分析和编译环境可以提高MySQL的执行效率存储过程是为以后使用而保存的一条或多条SQL语句，是SQL语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理。 可将其视为批文件，但作用不限于批处理。存储过程中可以包含控制语句。MySQL最新版本支持存储过程。存储过程三个优点：增强SQL语句的功能和灵活性较快的执行速度减少网络流量 创建存储过程123456789101112131415161718192021222324252627CREATE[DEFINER= &#123;user|CURRENT_USER&#125;]PROCEDURE sp_name(proc_parameter[,...])[characteristic...]routine_bodyproc_parameter:[IN|OUT|INOUT] para_name typeIN表示该参数的值必须在调用存储过程中指定（传递值给存储过程）OUT表示该参数值可以被存储过程改变，并且可以返回。（从存储过程返回值）INOUT表示该参数在调用时指定，并且可以被指定和返回。characteristic特性：COMMENT &apos;string&apos;|&#123;CONTAINS SQL|NO SQL|READS SQL DATA |MODIFIES SQL DATA&#125;|SQL SECURITY&#123;DEFINER|INVOKER&#125;COMMNET 注释CONTAINS SQL：包含SQL语句，但不包含读或写数据的语句NO SQL：不包含SQL语句READS SQL DATA：包含读数据的语句MODIFIES SQL DATA：包含写数据的语句SQL SECURITY&#123;DEFINER|INVOKER&#125;指明谁有权限来执行``` ### 过程体过程体由合法的SQL语句构成过程体可以是任意SQL语句过程体如果是复合结构（包含两个及以上的语句）则使用BEGIN…END语句。复合结构内可以包含声明、循环以及控制结构。``` bash$ mysql&gt; CREATE PROCEDURE sp1() SELECT VERSION(); 创建不带参数的存储过程显示MySQL版本1234$ mysql&gt; DELIMITER // -&gt; CREATE DEFINER=`root`@`localhost` PROCEDURE `sp1`() -&gt; SELECT VERSION()// /*显示MySQL版本*/ -&gt; DELIMITER ; 创建带有IN参数的存储过程从数据表删除指定记录123456789101112131415161718192021222324252627282930313233$ mysql&gt; DELIMITER //$ mysql&gt; CREATE PROCEDURE removeUserById(IN p_id INT UNSIGNIED) -&gt; BEGIN -&gt; DELETE FROM TEST WHERE id=p_id; -&gt; END -&gt; //``` ### 创建INOUT类型的存储过程$ mysql&gt; DELIMITER //$ mysql&gt; CREATE PROCEDURE RemoveUserAndReturnUserNums(IN p_id INT UNSIGNED,OUT nums INT UNSIGNED) -&gt; BEGIN -&gt; DELETE FROM TEST WHERE id=p_id; -&gt; SELECT COUNT(ID) FROM TEST INTO NUMS; -&gt; END -&gt; //$ mysql&gt; DELIMITER;$ mysql&gt; CALL RemoveUserAndReturnUserNums(1,@nums);@nums为用户变量与，MySQL客户端绑定，只对当前用户客户端有效。### 创建带多个OUT类型参数的存储过程SELECT ROW_COUNT();返回前一个SQL进行UPDATE、DELETE、INSERT操作所影响的行数。``` bash$ mysql&gt; DELIMITER //$ mysql&gt; CREATE PROCEDURE RemoveUsersByAgeAndReturnInfos(IN p_id INT UNSIGNED,OUT DeleteUsers SMALLINT UNSIGNED,OUT UserCounts SMALLINT UNSIGNED) -&gt; BEGIN -&gt; DELETE FROM test WHERE id =p_id; -&gt; SELECT ROW_COUNT() INTO DeleteUsers; -&gt; SELECT COUNT(id) from test INTO UserCounts; -&gt; END -&gt; //Query OK, 0 rows affected (0.00 sec)$ mysql&gt; DELIMITER ;$ mysql&gt; CALL RemoveUsersByAgeAndReturnInfos(8,@a,@b); 调用存储过程12CALL sp_name([parameter[,...]])CALL sp_name[()] 修改存储过程123ALTER PROCEDURE sp_name[characteristic...]COMMENT &apos;string&apos;|&#123;CONTAINS SQL|NO SQL|READS SQL DATA |MODIFIES SQL DATA&#125;|SQL SECURITY&#123;DEFINER|INVOKER&#125; 修改存储过程只能修改注释以及当前内容类型，不能修改过程体。若要修改过程体，只能先删除存储过程再创建存储过程。 删除存储过程1DROP PROCEDURE [IF EXISTS] sp_name 存储过程与自定义函数的区别存储过程实现的功能更加复杂，函数针对性更强存储过程可以返回多个值，自定义函数只能返回一个值存储过程一般独立来执行，自定义函数可以作为其他SQL语句的组成部分来出现。实际应用过程中很少使用函数，但是经常会把复杂的过程封装成存储过程。使用程序调用API相对于存储过程来说比较慢，可以把经常用的操作封装成存储过程。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL自定义函数]]></title>
    <url>%2F2017%2F07%2F07%2Fmysql-defined-function%2F</url>
    <content type="text"><![CDATA[什么是自定义函数？用户自定义函数 user-defined function UDF是一种对MySQL扩展的途径。自定义函数两个必要条件：（1）参数（并不是任何一个函数必备的要件）（2）返回值。函数可以返回任意类型的值，同样可以接收这些类型的参数。 创建自定义函数1234CREATE FUNCTION function_nameRETURNS&#123;STRING|INTEGER|REAL|DECIMAL&#125;routine_body routine_body 函数体（1）函数体由合法的SQL语句构成（2）函数体可以是简单的SELECT或者INSERT语句（3）函数体如果为复合结构则使用BEGIN…END语句（4）复合结构可以包含声明，循环，控制结构 创建带参数的自定义函数123456789101112131415161718192021CREATE FUNCTION F1(num1 SMALLINT UNSIGNED,num2 SMALLINT UNSIGNED)RETURNS FLOAT(10,2) UNSIGNEDRETURN (NUM1+NUM2)/2;``` ### 创建含有复合结构的自定义函数``` mysqlCREATE FUNCTION adduser(username varchar(10))RETURNS int(10) unsignedBEGIN INSERT test(username) values(username); RETURN LAST_INSERT_ID(); END;``` DELIMITER //修改Mysql默认的命令结束分隔符当函数体中有两个及两个以上的语句要执行，需要增加BEGIN…END 构成聚合体。### 删除自定义函数``` mysqlDROP FUNCTION [IF EXISTS] function_nameDROP FUNCTION F1; DESC 表名用于获取数据表结构，show columns from 表名也是获取数据表结构的。LAST_INSERT_ID()函数返回插入的那条记录在表中自增的那个字段的值。 执行自定义函数1SELECT function_name(参数)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决bash：mysql报错command not found办法]]></title>
    <url>%2F2017%2F07%2F03%2Fmysql-command-not-found%2F</url>
    <content type="text"><![CDATA[mac Command line命令行输入mysql -uroot -ppasswd报错”command not found”原因：系统默认查找/usr/local/bin目录下的命令，当命令不存在这个目录下，就会报错”command not found”。解决办法：在/usr/local/bin目录下建立软连接，链接到命令的所在目录12$ # cd /usr/local/bin$ # ln -fs /mysqlPATH/bin/mysql mysql 注：其中mysqlPATH为mysql的实际安装路径然后在Command Line下输入”mysql -uroot -ppasswd”问题解决。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL记录操作、表操作以及视图]]></title>
    <url>%2F2017%2F06%2F30%2FSQL-table-view%2F</url>
    <content type="text"><![CDATA[更新记录 UPDATE要删除某个列的值，可设置它为NULL123UPDATE Customers SET cust_email =NULLWHERE cust_id =&apos;100005&apos; 其中NULL用来去除cust_email列中的值，这与保存空字符串很不同，空字符串用’’表示，是一个值，而NULL表示没有值。 删除记录 DELETEDELET删除行，不需要列名和通配符。DELETE删除整行而不是删除列，删除指定的列，使用update语句。如果想从表中删除所有行，不要使用DELETE，使用TRUNCATE TABLE语句可以完成相同的工作，不记录数据变动，速度更快。 注意：在UPDATE DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证过滤的是正确的记录。 创建表12345678910111213CREATE TABLE order_iterms(order_num INTEGER NOT NULL,order_name CHAR(10) NOT NULL,quantity INTEGER NOT NULL DEFAULT 1);``` ### 更新表``` mysqlALTER TABLE order_itermsADD order_id CHAR(20);ALTER TABLE order_itermsDROP COLUMN order_id; 删除表1DROP TABLE order_iterms; 视图视图是虚拟的表，与包含数据的表不一样，是一个动态检索数据的查询。视图常见的应用：1、重用SQL语句2、简化复杂的SQL操作，在编写查询后，可以方便地重用它而不必知道其基本查询细节。3、使用表的一部分而不是整个表4、保护数据，可以授予用户访问表特定部分的权限而不是整个表的访问权限。5、更改数据格式与表示。视图可以返回与底层表的表示和格式不同的数据。创建视图之后，可以像对待数据表一样的使用。视图仅仅是用来查看存储在别处数据的一种设施，视图本身不包含数据。返回的数据是从其他表中检索出来的。创建视图CREATE VIEW删除视图DElETE VIEW创建视图，可以一次性编写基础的SQL，然后根据需要多次使用。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL分组查询与组合查询]]></title>
    <url>%2F2017%2F06%2F25%2FSQL-group-search%2F</url>
    <content type="text"><![CDATA[1.SOUNDEX()函数：将一个任何文本串转换为描述其语音表示的字母数字模式的语法。1SELECT name from Customers Where SOUNDEX(name)=SOUNDEX(&apos;Michael&apos;) 2.GROUP BY子句中的每一列都必须是检索列或者有效的表达式，不能是聚集函数。必须出现在WHERE语句之后，ORDER BY语句之前。3.HAVING过滤分组，WHERE过滤行，HAVING支持所有WHERE操作符。WHERE在分组前进行过滤，HAVING在分组后进行过滤。4.子查询作为做查询的SELECT语句只能查询单个列，若企图检索多个列将返回错误。5.关系表就是把信息分解成多个表，一类数据一个表，各表通过某些共同的值相互关联，所以才叫关系型数据库。6.组合查询UNION默认从查询结果集中自动去除了重复的行。如果想返回所有的匹配行，使用UNION ALL。UNION几乎可以完成与多个WHERE条件相同的工作。如果确实需要每个条件匹配行都出现（包括重复行），就必须使用UNION ALL而不是WHERE。7.对组合查询结果进行排序，只能只用一条ORDER BY子句，且必须位于最后一条SELECT语句之后。虽然OEDER BY子句似乎只是最后一条SELECT 语句的组成部分，但实际上DBMS将用它来排序所有SELECT语句返回的所有结果。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VFP数据库数据导入mysql]]></title>
    <url>%2F2017%2F06%2F21%2Fvfp-to-mysql%2F</url>
    <content type="text"><![CDATA[由于VFP数据库在2007年后就不再版本更新，其数据导入mysql很容易产生乱码，经过研究，发现先将VFP数据库数据导出成csv文件然后导入到mysql可以解决乱码问题。但数据中”?”很容易造成导出的csv文件错列，因此导出csv文件前需要清除”?”。CSTPCD数据库中可能存在问号的字段主要是lm、lme、dq、jjxm、y 等5个字段，需要依次对这5个字段清除”?” 解决数据中符号问题可以首先使用select distinct命令查看一下各字段数据都存在哪些符号。除”?”外，数据结尾的”,”等符号可能也会造成csv错列问题。 举例：清除”?”符号（lm字段） 双字节”?”符号1REPLACE ALL lm WITH CHRTRAN(lm,&apos;?&apos;,&apos;&apos;) FOR [?]$lm 单字节”?”符号12REPLACE ALL lm WITH CHRTRANC(lm,&apos;?&apos;,&apos;&apos;) FOR [?]$lmREPLACE ALL lm WITH SUBSTR(lm,1,LEN(ALLTRIM(lm))-1) FOR RIGHTC(ALLTRIM(lm),1)=[?] 导出CSV文件1Copy TO D:/myData.csv TYPE CSV 导入mysql直接使用图形化界面工具，如sequel pro等导入mysql数据库，或者LOAD DATA INFILE命令。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>VFP</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VFP数据处理常用的命令]]></title>
    <url>%2F2017%2F06%2F18%2FVFP-command%2F</url>
    <content type="text"><![CDATA[查找某个子字符串在某字符串中的位置12345678AT(‘要查找的子字符串’，’字符串’)ATC(‘要查找的子字符串’，’字符串’) 不考虑大小写ATCC(‘要查找的子字符串’，’字符串’) 当子字符串为单字节时 ATCC=ATC``` ### 截取字符串``` VFPSUBSTR(&apos;要截取的字符串&apos;,开始截取的位置,截取字符串个数) 从右边截取1RIGHT(&apos;要截取的字符串&apos;,截取字符串个数) 从左边截取1234567LEFT(&apos;要截取的字符串&apos;,截取字符串个数)``` ### 字符串中某些字符替换``` VFPCHRTRAN(字符串,&apos;要替换的某些字符&apos;,&apos;用来替换的字符&apos;)CHRTRAN(&apos;abcde&apos;,&apos;ad&apos;,&apos;lm&apos;) 返回’lbcme’ 判断字母、汉字、数字ISALPHA(lm) 判断是否是字母ISLOWER(lm) 判断是否是小写字母ISUPPER(lm) 判断是否是大写写字母ISLEADBYTE(lm) 判断是否是汉字等双字节字符ISDIGIT(lm) 判断是否是数字]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>VFP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[command-line]]></title>
    <url>%2F2017%2F06%2F17%2Fcommand-line%2F</url>
    <content type="text"><![CDATA[man命令查看所有命令的使用指南 command line命令规则1.对于大小写敏感，对于文件必须包含扩展名;2.文件绝对路径以”/“开头；相对路径什么也不写,如:”usr/local”;3.~表示当前用户目录;转义用”\“反斜杠(“空格，括号，引号，[]，!，$，&amp;，*，;，|，\”需要转义);4.mac系统卷由正斜杠/表示;其他卷在volumes文件夹中;5.Tab complete功能查询补足目录; 目录切换命令切换到其他目录或路径三个命令:cd、pwd、ls;1.cd “change directory”切换到指定目录;2.pwd “print working directory”显示当前目录绝对路径;3.ls”list directory contents”列出当前目录下的内容; 显示隐藏文件1.利用”-a”选项;2.”ls -la” “ls-lA”不显示”.”和”..”两个文件; “-l”是控制输出格式; comman-line管理文件命令1.cat 命令“concatenate” 按顺序读取文件并输出到Terminal窗口;可以通过\&lt;\&lt;命令来增加文本文件的内容;”cat text1.txt \&lt;\&lt; text2.txt”;把文本文件text2的内容增加到了text1的末尾;2.less适合查看长文件,和man命令一样的操作方式;3.which定位某个命令的文件路径;4.find根据搜索关键词定位文件路径,find后接搜索的起始路径,定义搜索的选项,搜索内容包含在引号里,find不使用spotlight服务,可以使用通配符*？[]; 递归命令1.使用递归命令”-r/-R”;可以允许命令不执行一个特定文件,而是指定路径下的所有文件; 编辑文件和文件夹1.mkdir “make directory” 创建文件夹;2.cp “copy” 把文件从一处复制到另一处 cp后接原始路径、目标路径;3.mv “move”用来移动文件 后接原路径+新路径 新文件名就成了重命名命令;4.rm “remove”永久删除文件命令 后接文件路径 如果希望安全删除文件，可以使用srm命令;5.rmdir “remove directory”永久删除文件夹，但无法删除包含其他文件的文件夹 rm -R命令删除文件夹以及包含的所有文件; 文本编辑器1.vi 可视化文本编辑器;2.nano更加现代的编辑器;3.按A进入编辑模式 ESC键退出编辑器 按住shift按两次Z保存退出，不想保存直接退出 :quit！ 切换用户1.su命令来切换用户 “substitute user identity” 后接用户名 可以用who -m来验证登录身份2.sudo “super user do”用sudo执行一个命令会使用root权限。若忘记使用sudo,sudo！！可以用sudo来执行上一条指令3.如果你是一个管理员用户,你需要执行很多条需要root 权限的命令,你可以临时切换整个命令行shell来取得root 级别的访问权限。方法就是先输入’sudo -s’，回车后再键入你的密码。 其他命令1.ctrl +C 可以终止一个错误或者发疯的命令2.ctrl+L清屏3.history命令查看历史记录]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>command命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用R语言计算一组关键词的TFIDF值]]></title>
    <url>%2F2017%2F06%2F16%2FTFIDF%2F</url>
    <content type="text"><![CDATA[R语言里提供了textir包来专门计算TFIDF值，具体计算步骤如下： 安装R包textir1$ install.packages(“textir”) 选择一个镜像站安装即可 加载R包textir1library(textir) 加载包textir 的同时需要安装其他包（有提示）1234$ library(distrom)$ library(Matrix)$ library(gamlr) $ library(parallel) 导入csv数据1234567891011$ data\&lt;-read.table(&quot;infor.csv&quot;, header=T,sep=&quot;,&quot;)#转成矩阵$ a\&lt;-as.matrix(data)#转成数值型矩阵$ b\&lt;-matrix(as.numerix(a),nrow=nrow(a))#矩阵转置$ c\&lt;-t(b)#TFIDF计算$ d\&lt;-tfidf(c,normalize=T)#计算得到的数据再转置复原$ data\&lt;-t(d) 导出csv数据1$ write.table(data,”Mydata.csv”,sep=”,”) 转换成其他格式也可以]]></content>
      <categories>
        <category>数据处理</category>
      </categories>
      <tags>
        <tag>TFIDF</tag>
        <tag>R</tag>
      </tags>
  </entry>
</search>
